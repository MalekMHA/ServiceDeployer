package core;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import org.jgrapht.graph.DirectedWeightedMultigraph;
import nodes.AbstractNode;
import nodes.Node;

public class FeasibilityFastVulnerabilityOverVulnerabilityRange {

	public static void main(String[] args) {
		Random random = new Random();
		String file = "FeasibilityFastVulnerabilityOverVulnerabilityRange.csv";
		FileWriter fw;
			try {
				fw = new FileWriter(file);
				PrintWriter pw = new PrintWriter(fw, true); 
				int size = 16;
				
				for (int range = 0; range <= 1000; range += 100) {
					List<Float> vulnerabilities = new ArrayList<>();
					for (int sample = 0; sample < 50; sample++) {
						long startTime = System.nanoTime();
						AbstractGraph abstracted = CreateRandomNetwork(size, range);
						DirectedWeightedMultigraph<Node, Edge> expandedGraph = NetworkExpander.generateExpandedGraph(abstracted, 5);
						long expansionTime = System.nanoTime();
						List<Path> validPaths = Traversal.TraverseSP(expandedGraph, abstracted, abstracted.getProducer().getProcessNode(), abstracted.getConsumer().getProcessNode(), 15000f);
						long traversalTime = System.nanoTime();
						
						int bestPathIndex = -1;
						Path bestPath = null;
						if (validPaths.size() > 0) {
							bestPathIndex = random.nextInt(validPaths.size());
							bestPath = validPaths.get(bestPathIndex);
							float vulnerability = bestPath.getVulnerability();
							vulnerabilities.add(vulnerability);
						}
						
						long endTime = System.nanoTime();
						long dExpansionTime = (expansionTime - startTime)/1000000;
						long dTraversalTime = (traversalTime - expansionTime)/1000000;
						long dBestPathTime = (endTime - traversalTime)/1000000;
						long importantTime = (endTime - expansionTime)/1000000;
						
						if (bestPathIndex >= 0) {					
							System.out.println("Vulnerability range: " + range + " | Sample: " + sample + " | Generated expanded graph in " + dExpansionTime + " | Traversed path in " + dTraversalTime + " | Found best path in " + dBestPathTime + " | Total time: " + importantTime + " | Number of valid paths: " + validPaths.size() + " | Best path vulnerability: " + validPaths.get(bestPathIndex).getVulnerability() + " | Best path: " );
						} else {
							System.out.println("Vulnerability range: " + range + " | Sample: " + sample + " | Generated expanded graph in " + dExpansionTime + " | Traversed path in " + dTraversalTime + " | Found best path in " + dBestPathTime + " | Total time: " + importantTime + " | Number of valid paths: " + validPaths.size() + " | Best path: None");
						}
					}
					
					pw.print(size + ",");
					for (float v : vulnerabilities) {
						pw.print(v);
						pw.print(",");
					}
					pw.println();
					
				}
				
				pw.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} 
		
//		System.out.println("Valid paths:");
//		for (Path p : validPaths) {
//			for (Node n : p.getNodes()) {
//				System.out.print(abstracted.getNodeDescription(n) + "; ");
//			}
//			System.out.println();
//		}
	}
	
	private static AbstractGraph CreateRandomNetwork(int size, int range){
		Random r = new Random();
		AbstractGraph result = new AbstractGraph(Edge.class);
		
		// Encryption Schemes
		EncryptionScheme scheme1 = new EncryptionScheme(0);
		EncryptionScheme scheme2 = new EncryptionScheme(-range);
		
		// Create nodes and edges such that the network is connected.
		for (int i = 0; i < size; i++) {
			// Node
			AbstractNode node = new AbstractNode();
			
			// Processor
			Processor processor = new Processor() {
				float minProcessingLatency = 400f, maxProcessingLatency = 700f;
				Random r = new Random();
				float processingLatency = r.nextFloat() * (maxProcessingLatency - minProcessingLatency) + minProcessingLatency;
				
				@Override protected float GetProcessingLatency(int b) {return processingLatency*b;}
			};
			
			r.nextFloat();
			
			node.setProcessor(processor);
			node.addEncryptionScheme(scheme1, r.nextFloat() * 50 + 300 - 25);
			node.addEncryptionScheme(scheme2, r.nextFloat() * 50 + 600 - 25);
			node.SetEnd(false);
			result.addVertex(node);
			
			if (result.vertexSet().size() > 1) {				
				ConnectVertexToRandomVertexInGraph(result, node, new ArrayList<AbstractNode>(), range);
			}
		}
		
		// Create end nodes
		List<AbstractNode> endNodes = new ArrayList<>();
		for (int i = 0; i < 2; i++) {
			// Node
			AbstractNode node = new AbstractNode();
			
			// Processor
			Processor processor = new Processor() {
				@Override protected float GetProcessingLatency(int b) {return 100*b;}
			};
			
			node.setProcessor(processor);
			node.addEncryptionScheme(scheme1, r.nextFloat() * 50 + 400 - 25);
			node.addEncryptionScheme(scheme2, r.nextFloat() * 100 + 800 - 50);
			node.SetEnd(true);
			node.setName("a"+i);
			endNodes.add(node);
			result.addVertex(node);
			
			ConnectVertexToRandomVertexInGraph(result, node, endNodes, range);
		}
		result.setProducer(endNodes.get(0));
		result.setConsumer(endNodes.get(1));
		
		// Saturate the network with more edges randomly
//		int numberOfRandomEdges = 0;
//		for (AbstractNode n1 : result.vertexSet()) {
//			float roll = r.nextFloat();
//			if (roll <= 0.05) {
//				ConnectVertexToRandomVertexInGraph(result, n1, endNodes, range);
//			}
//		}
		// System.out.println("Number of random edges: " + numberOfRandomEdges);
		
		// Cloud
		List<AbstractNode> nonEdgeNodes = new ArrayList<>();
		nonEdgeNodes.addAll(endNodes);
		AbstractNode cloud = new AbstractNode();
		cloud.addEncryptionScheme(scheme1, r.nextFloat() * 20 + 50 - 10);
		cloud.addEncryptionScheme(scheme2, r.nextFloat() * 20 + 100 - 10);
		cloud.setProcessor(new Processor() {@Override protected float GetProcessingLatency(int b) {return 100*b;}});
		result.addVertex(cloud);
		nonEdgeNodes.add(cloud);
		
		ConnectVertexToRandomVertexInGraph(result, cloud, endNodes, range);
		
		
		return result;
	}
	
	private static void ConnectVertexToRandomVertexInGraph(AbstractGraph graph, AbstractNode node, List<AbstractNode> exceptions, int range) {
		Random random = new Random();
		
		AbstractNode connectTo = null;
		int randomIndex = random.nextInt(graph.vertexSet().size());
		int j = 0;
		for (AbstractNode n : graph.vertexSet()) {
			if (n == node || exceptions.contains(n)) {
				ConnectVertexToRandomVertexInGraph(graph, node, exceptions, range);
				return;					
			}
			if (j == randomIndex){
				connectTo = n;
				break;
			}
			j++;
		}
		
		float latency = random.nextFloat() * 200 + 50;
		float v = random.nextFloat() * 50 + range;
		Edge e1 = new Edge(latency, v, true), e2 = new Edge(latency, v, true);				
		graph.addEdge(node, connectTo, e1);
		graph.addEdge(connectTo, node, e2);
	}

}
